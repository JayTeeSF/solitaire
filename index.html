<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solitaire Game</title>
    <style>
body {
  font-family: Arial, sans-serif;
  text-align: center;
  margin: 0;
  padding: 0;
}

      #game-board {
        display: inline-block;
        text-align: left;
        margin: 10px;
      }

      #controls {
        margin-top: 20px;
      }

      button {
        padding: 10px 20px;
        font-size: 16px;
      }

      @media screen and (max-width: 600px) {
        body {
          font-size: 14px;
        }

        #game-board {
          margin: 5px;
        }

        button {
          font-size: 14px;
        }
      }
    </style>
  </head>
  <body style="font-family: Arial, sans-serif; text-align: center;">

    <div id="game-board" style="display: inline-block; text-align: left; margin: 10px;">
      <!-- Stacks, cards, and suits will be dynamically generated using inline JavaScript -->
    </div>
    <div id="controls" style="margin-top: 20px;">
      <button id="new-game" style="padding: 10px 20px; font-size: 16px;">New Game</button>
      <button id="hint" style="padding: 10px 20px; font-size: 16px;">Hint</button>
      <button id="reset-deck" style="padding: 10px 20px; font-size: 16px;">Reset Deck</button>
    </div>

    <script>
      // JavaScript code for the solitaire game
      // Define data structures and game logic here

      // Initialize deck as a global variable
      const deck = [];

      // Initialize tableau as an array of empty arrays
      const tableau = [[], [], [], [], [], [], []];
      /*
      // Initialize tableau as an empty array
      // const tableau = [];
      */


      // Define the Card class
      class Card {
        constructor(suit, rank) {
          this.suit = suit;
          this.rank = rank;
          this.flipped = false;
        }

        // Function to create a card representation
        createCardElement() { // suit, rank) {
          const cardElement = document.createElement('div');
          cardElement.style.width = '60px';
          cardElement.style.height = '80px';
          cardElement.style.border = '1px solid #000';
          cardElement.style.textAlign = 'center';
          cardElement.style.fontSize = '20px';
          cardElement.style.background = 'white';
          cardElement.style.position = 'relative';
          cardElement.textContent = this.getRepresentation();

          return cardElement;
        }

        // Method to flip the card
        flip() {
          this.flipped = !this.flipped;
        }

        // Method to get the card's representation
        getRepresentation() {
          if (this.flipped) {
            return 'Back';
          } else {
            return `${this.rank} ${suitSymbol[this.suit]}`;
          }
        }
      }

      const CARD_RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
      const SUITS = ['H', 'S', 'C', 'D'];

      const suitSymbol = {
        "H": "♥",
        "S": "♠",
        "C": "♣",
        "D": "♦"
      };

      // Initialize gameBoard as a global variable
      const gameBoard = document.getElementById('game-board');

      // Event listeners for card movement and game controls
      document.getElementById('new-game').addEventListener('click', newGame);

      function provideHint() {
        // Implement logic to provide hints to the player
      }

      document.getElementById('hint').addEventListener('click', provideHint);

      function resetDeck() {
        // Implement logic to reset the deck
      }

      document.getElementById('reset-deck').addEventListener('click', resetDeck);

      // Function to update the game board based on the game state
      function updateGameBoard() {
        // Update the HTML elements to reflect the game state
        // Dynamically generate stacks, cards, and suits
          // Clear the existing card elements from the tableau stacks
        for (let i = 0; i < tableau.length; i++) {
          while (tableau[i].firstChild) {
            tableau[i].removeChild(tableau[i].firstChild);
          }
        }

        // Add card elements for the remaining cards in each stack
        for (let i = 0; i < tableau.length; i++) {
          for (let j = tableau[i].length - 1; j >= 0; j--) {
            const card = tableau[i][j];
            // const cardElement = createCard(card);

            // tableau[i].appendChild(cardElement);
            tableau[i][0].appendChild(card);
          }
        }
      }

      // Initialize the game when the page loads
      window.onload = () => {
        // Call renderTableau and assign the returned value to the global variable
        renderTableau(gameBoard);
        // and foundations areas
        renderFoundations(gameBoard);

        // Call newGame to start a new game
        newGame();
      };

      // Render the tableau area
      function renderTableau(gameBoard) {
        const tableauContainer = document.createElement('div');
        tableauContainer.style.display = 'flex';

        for (let i = 0; i < 7; i++) {
          const tableauStack = document.createElement('div');
          tableauStack.style.margin = '10px';

          tableauContainer.appendChild(tableauStack);
          tableau[i].push(tableauStack); // Append to both display and array
          /*
            // tableau[i] = tableauStack; // Assign the tableau stack directly to the corresponding sub-array

            // tableau[i].push(tableauStack); // Append the tableau stack to the tableau array
            //tableau[i] = tableauStack; // Assign the tableau stack directly to the corresponding sub-array
           */
        }

        // Only append container once
        gameBoard.appendChild(tableauContainer); 
      }

      // Function to render the foundations area
      function renderFoundations(gameBoard) {
        const foundationsContainer = document.createElement('div');
        foundationsContainer.style.display = 'flex';
        foundationsContainer.style.justifyContent = 'space-around';

        for (let i = 0; i < 4; i++) {
          const foundationStack = document.createElement('div');
          foundationStack.style.margin = '10px';

          foundationsContainer.appendChild(foundationStack);
        }

        gameBoard.appendChild(foundationsContainer);
      }

      // Function to create a new game
      function newGame() {
        // Create a new deck
        createDeck();

        // Shuffle the deck
        shuffleDeck();

        // Deal cards to the tableau with animation
        dealCardsWithAnimation(tableau, deck, gameBoard);

        // Update the game board to reflect the new game state
        updateGameBoard();
      }

      // Function to create a new deck
      function createDeck() {
        for (let suit of SUITS) {
          for (let rank of CARD_RANKS) {
            deck.push(new Card(suit, rank));
          }
        }
      }

      Array.prototype.dealCard = function() {
        if (this.length > 0) {
          return this.pop();
        } else {
          throw new Error('Deck is empty');
        }
      };

      // Function to shuffle the deck
      function shuffleDeck() {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
      }

      // Function to deal cards to the tableau with animation
      function dealCardsWithAnimation(tableau, deck, gameBoard) {
        for (let i = 0; i < tableau.length; i++) {
          for (let j = 0; j <= i; j++) {
            const card = deck.dealCard();
            card.flip();

            // Add card to appropriate tableau array
            tableau[i].push(card);

            const cardElement = card.createCardElement();
            cardElement.style.opacity = 0;

            // Append to first element in tableau array 
            tableau[i][0].appendChild(cardElement);

            setTimeout(() => {
              cardElement.style.opacity = 1;
            }, 500 * j);
          }

          tableau[i][tableau[i].length - 1].flip();
        }
      }

      function isValidMoveTableauToTableau(sourceStack, destinationStack) {
        if (sourceStack === destinationStack) {
          return

          false;
        }

        if (destinationStack.length === 0) {
          return sourceStack[sourceStack.length - 1].rank === 'K';
        }

        const sourceCard = sourceStack[sourceStack.length - 1];
        const destinationCard = destinationStack[destinationStack.length - 1];

        return (
          sourceCard.suit !== destinationCard.suit &&
          CARD_RANKS.indexOf(sourceCard.rank) === CARD_RANKS.indexOf(destinationCard.rank) - 1
        );
      }

      function isValidMoveTableauToFoundations(card, foundations) {
        const stack = foundations[SUITS.indexOf(card.suit)];
        if (stack.length === 0) {
          return card.rank === 'A';
        }

        const topCard = stack[stack.length - 1];
        return CARD_RANKS.indexOf(card.rank) === CARD_RANKS.indexOf(topCard.rank) + 1;
      }

      function moveCard(sourceStack, destinationStack) {
        if (isValidMoveTableauToTableau(sourceStack, destinationStack)) {
          destinationStack.push(sourceStack.pop());
        } else

          if (isValidMoveTableauToFoundations(sourceStack[sourceStack.length - 1], foundations)) {
            foundations[SUITS.indexOf(sourceStack[sourceStack.length - 1].suit)].push(sourceStack.pop());
          }
      }
    </script>
  </body>
</html>
